#!/bin/bash

_print_help_msg() {
    cat <<'END_HELP_MSG'
Usage: ./vagrant-pytest [-B] [-D] [-H] [-K] [-S] <pytest_args..>

vagrant-pytest is a wrapper around pytest, running it inside a Ubuntu Linux
virtualbox virtual machine that is created and managed using vagrant, making the
VM reproducible for all yaesm developers. This program expects to be run from
the root of the yaesm source tree. Note that this script will leave behind
vagrant artifacts in a directory named '.vagrant' at the root of the yaesm
source tree. Refer to the official vagrant documentation for more information
about vagrant. See the file 'Vagrantfile_pytest' for more information about the
virtual machine environment.

Options:
  -B            Force rebuild of the virtual machine
  -D            Run this program in debug mode (set -x)
  -H            Print this help message and exit 0
  -S            Create a snapshot of the virtual machine after executing pytest

Examples:
  ./vagrant-pytest tests
  ./vagrant-pytest -H
  ./vagrant-pytest -B -S --show-capture=stdout --fixtures-per-test tests
END_HELP_MSG
}

_run() { # _run() is a basic command running wrapper that crashes this script if the command fails
    local e=''
    if [[ $- == *e* ]]; then
        e='set'
    fi
    set -e
    "$@"
    if [ -n "$e" ]; then set -e; else set +e; fi
    return 0
}

_die() {
    local msg=$1
    1>&2 printf 'vagrant-pytest: fatal error: %s\n' "$msg"
    exit 1
}

trap 'if [[ $- == *e* ]]; then 1>&2 printf "vagrant-pytest: fatal command failure: %s\n" "$BASH_COMMAND"; exit 1; fi' ERR

OPTS_PYTEST=''
OPT_DEBUG=1
OPT_VM_FORCE_BUILD=1
OPT_VM_KEEP_RUNNING=1
OPT_VM_SAVE_SNAPSHOT=1
while [ -n "$1" ]; do # This script uses single capital letter opts to not clash with pytest opts.
    case "$1" in
        -B)
          OPT_VM_FORCE_BUILD=0
          shift
          ;;
        -D)
          set -x
          PS4='vagrant-pytest: line $LINENO: DEBUG: '
          shift
          ;;
        -H)
          _print_help_msg
          exit 0
          ;;
        -S)
          OPT_VM_SAVE_SNAPSHOT=0
          shift
          ;;
        *)
          OPTS_PYTEST="$OPTS_PYTEST $1"
          shift
          ;;
    esac
done

which vagrant    >/dev/null 2>&1 || _die 'vagrant not in $PATH'
which virtualbox >/dev/null 2>&1 || _die 'virtualbox not in $PATH'
which rsync      >/dev/null 2>&1 || _die 'rsync not in $PATH'
lsmod | grep -q vboxdrv          || _die 'vboxdrv kernel module not loaded'
if [ "$(basename $(pwd))" != yaesm -o ! -f Vagrantfile_pytest -o ! -d src -o ! -d tests ]; then
    _die 'not in yaesm root directory'
fi

export VAGRANT_VAGRANTFILE=Vagrantfile_pytest

VM_STATE=$(_run vagrant status yaesm-pytest --machine-readable | grep ',yaesm-pytest,state,' | awk -F',' '{ORS=""; print $NF}')
[ $VM_STATE != not_created ]
VM_BUILT=$?

if [ running == $VM_STATE ]; then
    _run vagrant halt yaesm-pytest
     VM_STATE=poweroff
fi

if [ 0 -eq $OPT_VM_FORCE_BUILD ] && [ 0 -eq $VM_BUILT ]; then
    _run vagrant destroy -f yaesm-pytest
    _run vagrant global-status --prune
    VM_STATE=not_created
    VM_BUILT=1
fi

if [ 0 -ne $VM_BUILT ]; then
    _run vagrant up --provider virtualbox --no-install-provider yaesm-pytest
    _run vagrant halt yaesm-pytest
    _run vagrant snapshot save -f yaesm-pytest yaesm-pytest-postbuild-snapshot
    VM_BUILT=1
fi

# vagrant snapshot restore starts the VM
_run vagrant snapshot restore yaesm-pytest yaesm-pytest-postbuild-snapshot

vagrant ssh -c "sudo bash -c 'cd /home/vagrant/yaesm && . /home/vagrant/yaesm-venv/bin/activate && pytest $OPTS_PYTEST'"
PYTEST_STATUS=$?

if [ 0 -ne $OPT_VM_KEEP_RUNNING ]; then
    _run vagrant halt yaesm-pytest
fi

if [ 0 -eq $OPT_VM_SAVE_SNAPSHOT ]; then
    local snapshot_name="yaesm-pytest-$(date +%Y_%m_%d_%H:%M)"
    _run vagrant snapshot save yaesm-pytest "$snapshot_name"
fi

exit $PYTEST_STATUS
