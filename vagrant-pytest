#!/bin/bash

_print_help_msg() {
    cat <<'END_HELP_MSG'
Usage: vagrant-pytest [-B] [-D] [-H] [-K] [-S] <pytest_args..>

vagrant-pytest is a wrapper around pytest, running it inside a Ubuntu Linux
VirtualBox virtual machine that is created and managed using vagrant. By using
Vagrant and VirtualBox, the virtual machine is reproducible, can be snapshotted,
and allows all pytest runs to start in a clean environment regardless of
previous runs.

For more information about the virtual machine environment see the file
Vagrantfile_pytest. For more information about Vagrant, VirtualBox, and pytest,
refer to their respective documentation.

This program should exit with the same status as the pytest run, however in the
case of an unexpected failure or misconfigured environment it exits with status
73.

Options:
  -B            Force rebuild of the virtual machine
  -D            Run this program in debug mode (set -x)
  -H            Print this help message and exit 0
  -S            Create a snapshot of the virtual machine after executing pytest

Examples:
  ./vagrant-pytest tests
  ./vagrant-pytest -H
  ./vagrant-pytest -B -S --show-capture=stdout --fixtures-per-test tests
END_HELP_MSG
}

set -E

_run() {
    local e=''
    if [[ $- == *e* ]]; then
        e='set'
    fi
    set -e
    eval "$@"
    if [ -n "$e" ]; then set -e; else set +e; fi
    return 0
}

_die() {
    local msg=$1
    1>&2 printf 'vagrant-pytest: fatal error: %s\n' "$msg"
    exit 73
}

trap 'if [[ $- == *e* ]]; then 1>&2 printf "vagrant-pytest: fatal command failure: %s\n" "$BASH_COMMAND"; exit 73; fi' ERR

OPTS_PYTEST=''
OPT_DEBUG=1
OPT_VM_FORCE_BUILD=1
OPT_VM_KEEP_RUNNING=1
OPT_VM_SAVE_SNAPSHOT=1
while [ -n "$1" ]; do # This script uses single capital letter opts to not clash with pytest opts.
    case "$1" in
        -B)
          OPT_VM_FORCE_BUILD=0
          shift
          ;;
        -D)
          set -x
          PS4='vagrant-pytest: line $LINENO: DEBUG: '
          shift
          ;;
        -H)
          _print_help_msg
          exit 0
          ;;
        -S)
          OPT_VM_SAVE_SNAPSHOT=0
          shift
          ;;
        *)
          OPTS_PYTEST="$OPTS_PYTEST $1"
          shift
          ;;
    esac
done

which vagrant    >/dev/null 2>&1 || _die 'vagrant not in $PATH'
which virtualbox >/dev/null 2>&1 || _die 'virtualbox not in $PATH'
which rsync      >/dev/null 2>&1 || _die 'rsync not in $PATH'
lsmod | grep -q vboxdrv          || _die 'vboxdrv kernel module not loaded'
if [ "$(basename $(pwd))" != yaesm -o ! -f Vagrantfile_pytest -o ! -d src -o ! -d tests ]; then
    _die 'not in yaesm root directory'
fi

export VAGRANT_VAGRANTFILE=Vagrantfile_pytest

VM_STATE=$(_run vagrant status yaesm-pytest --machine-readable | grep ',yaesm-pytest,state,' | awk -F',' '{ORS=""; print $NF}')
[ $VM_STATE != not_created ]
VM_BUILT=$?

if [ running == $VM_STATE ]; then
    _run vagrant halt yaesm-pytest
     VM_STATE=poweroff
fi

if [ 0 -eq $OPT_VM_FORCE_BUILD ] && [ 0 -eq $VM_BUILT ]; then
    _run vagrant destroy -f yaesm-pytest
    _run vagrant global-status --prune
    VM_STATE=not_created
    VM_BUILT=1
fi

if [ 0 -ne $VM_BUILT ]; then
    _run vagrant up --provider virtualbox --no-install-provider yaesm-pytest
    _run vagrant halt yaesm-pytest
    _run vagrant snapshot save -f yaesm-pytest yaesm-pytest-postbuild-snapshot
    VM_BUILT=1
fi

# vagrant snapshot restore starts the VM
_run vagrant snapshot restore yaesm-pytest yaesm-pytest-postbuild-snapshot

vagrant ssh -c "sudo bash -c 'cd /home/vagrant/yaesm && . /home/vagrant/yaesm-venv/bin/activate && pytest $OPTS_PYTEST'"
PYTEST_STATUS=$?

if [ 0 -ne $OPT_VM_KEEP_RUNNING ]; then
    _run vagrant halt yaesm-pytest
fi

if [ 0 -eq $OPT_VM_SAVE_SNAPSHOT ]; then
    local snapshot_name="yaesm-pytest-$(date +%Y_%m_%d_%H:%M)"
    _run vagrant snapshot save yaesm-pytest "$snapshot_name"
fi

exit $PYTEST_STATUS
